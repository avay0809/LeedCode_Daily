You are given a 2D integer array squares. Each squares[i] = [xi, yi, li] represents the 
coordinates of the bottom-left point and the side length of a square parallel to the x-axis.
Find the minimum y-coordinate value of a horizontal line such that the total area covered 
by squares above the line equals the total area covered by squares below the line.

Answers within 10-5 of the actual answer will be accepted.
Note: Squares may overlap. Overlapping areas should be counted only once in this version.

Example 1:
Input: squares = [[0,0,1],[2,2,1]]
Output: 1.00000
Explanation:
Any horizontal line between y = 1 and y = 2 results in an equal split, with 1 square unit above and 1 square unit below. The minimum y-value is 1.

Example 2:
Input: squares = [[0,0,2],[1,1,1]]
Output: 1.00000
Explanation:
Since the blue square overlaps with the red square, it will not be counted again. Thus, the line y = 1 splits the squares into two equal parts.

Constraints:
1 <= squares.length <= 5 * 104
squares[i] = [xi, yi, li]
squares[i].length == 3
0 <= xi, yi <= 109
1 <= li <= 109
The total area of all the squares will not exceed 1015.

Time Complexity	O(N log N)
Space Complexity	O(N)

----------------------------------------------------------JAVA---------------------------------------------------------------------------


CODE

class Solution {
    static class Event {
        long y, x1, x2;
        int type; // +1 = add, -1 = remove

        Event(long y, long x1, long x2, int type) {
            this.y = y;
            this.x1 = x1;
            this.x2 = x2;
            this.type = type;
        }
    }

    public double separateSquares(int[][] squares) {
        List<Event> events = new ArrayList<>();

        // Create events
        for (int[] s : squares) {
            long x = s[0], y = s[1], l = s[2];
            events.add(new Event(y, x, x + l, 1));
            events.add(new Event(y + l, x, x + l, -1));
        }

        // Sort by y
        events.sort(Comparator.comparingLong(e -> e.y));

        TreeMap<Long, Integer> active = new TreeMap<>();
        long prevY = events.get(0).y;
        double totalArea = 0;

        // Calculate total union area
        for (Event e : events) {
            long dy = e.y - prevY;
            if (dy > 0) {
                long width = unionXLength(active);
                totalArea += width * dy;
                prevY = e.y;
            }
            update(active, e);
        }

        //  Find minimum y where area reaches half
        double half = totalArea / 2;
        active.clear();
        prevY = events.get(0).y;
        double area = 0;

        for (Event e : events) {
            long dy = e.y - prevY;
            if (dy > 0) {
                long width = unionXLength(active);
                double slice = width * dy;

                if (area + slice >= half) {
                    return prevY + (half - area) / width;
                }

                area += slice;
                prevY = e.y;
            }
            update(active, e);
        }

        return prevY;
    }

    // Maintain active x-intervals
    private void update(TreeMap<Long, Integer> map, Event e) {
        map.put(e.x1, map.getOrDefault(e.x1, 0) + e.type);
        map.put(e.x2, map.getOrDefault(e.x2, 0) - e.type);

        if (map.get(e.x1) == 0) map.remove(e.x1);
        if (map.get(e.x2) == 0) map.remove(e.x2);
    }

    // Compute union length of x-intervals
    private long unionXLength(TreeMap<Long, Integer> map) {
        long length = 0;
        int count = 0;
        Long prev = null;

        for (Map.Entry<Long, Integer> e : map.entrySet()) {
            if (count > 0 && prev != null) {
                length += e.getKey() - prev;
            }
            count += e.getValue();
            prev = e.getKey();
        }
        return length;
    }
}





